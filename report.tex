\documentclass[12pt,letterpaper]{article}

% All packages must be in preamble (before \begin{document})
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{url}
\usepackage{verbatim}

% Simple page numbering
\pagestyle{plain}

\begin{document}

% ============================================================================
% COVER PAGE
% ============================================================================
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\Huge\bfseries Virtual Private Network (VPN) Implementation\par}
    \vspace{1cm}
    {\Large Secure Tunneling with AES-256 Encryption and HMAC Authentication\par}
    \vspace{2cm}
    
    {\Large\textbf{CS462 Computer Networks}\par}
    \vspace{0.5cm}
    {\large Final Project Report\par}
    \vspace{2cm}
    
    {\large
    \textbf{Instructor:} Professor Juan\\
    \textbf{Semester:} Fall 2024\\
    \textbf{Date:} November 2024\\
    }
    \vspace{2cm}
    
    {\large
    \textbf{Group ID:} [TO BE FILLED IN]\\
    \vspace{0.5cm}
    \textbf{Team Members:}\\
    {[Student Name 1]}\\
    {[Student Name 2]}\\
    {[Student Name 3]}\\
    {[Student Name 4]}\\
    }
    
    \vfill
\end{titlepage}

% ============================================================================
% TABLE OF CONTENTS
% ============================================================================
\tableofcontents
\newpage

% ============================================================================
% SECTION 1: ORGANIZATION AND EFFORT
% ============================================================================
\section{Organization and Effort}

\subsection{Revision History}

\begin{center}
\begin{tabular}{|l|l|l|p{6cm}|}
\hline
\textbf{Version} & \textbf{Date} & \textbf{Modifier} & \textbf{Description} \\
\hline
1.0 & [Date] & [Name] & Initial VPN implementation with basic encryption \\
\hline
1.1 & [Date] & [Name] & Fixed critical IV reuse vulnerability \\
\hline
2.0 & [Date] & [Name] & Added comprehensive security tests and documentation \\
\hline
2.1 & [Date] & [Name] & Performance testing and optimization \\
\hline
3.0 & [Date] & [Name] & Final version with complete documentation \\
\hline
\end{tabular}
\end{center}

\subsection{Effort Distribution}

\begin{center}
\begin{tabular}{|l|p{6cm}|c|c|}
\hline
\textbf{Team Member} & \textbf{Contribution} & \textbf{Hours} & \textbf{Percentage} \\
\hline
[Name 1] & VPN core implementation, TUN interface & [X] & [Y\%] \\
\hline
[Name 2] & Cryptographic implementation, security testing & [X] & [Y\%] \\
\hline
[Name 3] & Performance testing, documentation & [X] & [Y\%] \\
\hline
[Name 4] & Architecture design, testing framework & [X] & [Y\%] \\
\hline
\end{tabular}
\end{center}

\textbf{Note:} Customize the above table based on your actual team composition and work distribution.

% ============================================================================
% SECTION 2: OBJECTIVES AND SYSTEM SPECIFICATION
% ============================================================================
\section{Objectives and System Specification}

\subsection{Project Objectives}

The primary objective of this project was to design and implement a functional Virtual Private Network (VPN) that enables secure communication between two or more hosts over an untrusted network. This implementation demonstrates several core networking and security concepts, beginning with secure tunneling to create virtual point-to-point connections over IP networks. To ensure data confidentiality, we implemented AES-256 encryption in CTR mode, which provides strong cryptographic protection for all transmitted data. Authentication was achieved through HMAC-SHA256, ensuring both data integrity and authenticity of communications. The project also required proper packet encapsulation using UDP/IPv4 protocol layering with a carefully designed packet structure. Finally, we conducted comprehensive security analysis to validate the system's adherence to the CIA triad: Confidentiality, Integrity, and Availability.

\subsection{System Requirements}

\subsubsection{Functional Requirements}

The functional requirements for this VPN system can be organized into four primary categories. First, regarding VPN connectivity (FR1), the system must establish a secure tunnel between two hosts while supporting bidirectional communication. This connectivity is achieved through TUN interfaces, which enable packet capture and injection at the network layer.

For encryption and authentication (FR2), the system implements AES-256 encryption to ensure data confidentiality and employs HMAC-SHA256 for message authentication. A critical security requirement is the generation of unique initialization vectors (IVs) for each encrypted packet, preventing cryptographic vulnerabilities associated with IV reuse. Additionally, the system derives separate keys for encryption and HMAC operations, following best practices in cryptographic key management.

The packet encapsulation requirements (FR3) specify that the system must encapsulate IP packets within encrypted UDP datagrams. Each packet includes sequence numbers for replay protection and an HMAC tag for integrity verification. The packet format follows a specific structure: a 16-byte IV, followed by a 4-byte sequence number, a 32-byte HMAC, and finally the variable-length encrypted payload.

Security requirements (FR4) are paramount to the system's design. The implementation must protect against replay attacks through sequence number verification and detect any tampering attempts via HMAC validation, immediately rejecting compromised packets. Furthermore, the system prevents unauthorized decryption by parties without the correct key and maintains semantic security, ensuring that encrypting the same plaintext multiple times produces different ciphertexts.

\subsubsection{Non-Functional Requirements}

Performance requirements (NFR1) establish benchmarks for system efficiency. The implementation must achieve encryption throughput exceeding 500 Mbps for MTU-sized packets while maintaining encryption latency below 0.1 milliseconds per packet. Additionally, the protocol overhead must remain under 5\% for MTU-sized packets to minimize bandwidth consumption.

Reliability requirements (NFR2) ensure robust operation under various network conditions. The system must gracefully handle network interruptions without crashing or corrupting data, and it must detect and reject malformed packets to prevent security vulnerabilities or system instability.

Usability requirements (NFR3) focus on operational simplicity and transparency. The system provides a clear command-line interface for configuration and operation, and it logs all encryption and decryption events to enable debugging and security auditing.

\subsection{System Specification}

\subsubsection{Architecture Overview}

The VPN system architecture is built upon three main components that work together to provide secure communication. The TUN Interface Module serves as a virtual network interface that captures outgoing IP packets and injects incoming packets into the operating system's network stack. The Cryptographic Module handles all encryption, decryption, and authentication operations, ensuring data confidentiality and integrity. Finally, the Network Module manages UDP socket communication, transmitting encrypted packets between VPN endpoints over the physical network.

\subsubsection{Technology Stack}

The implementation leverages several modern technologies to achieve its objectives. Python 3.7 or higher serves as the primary programming language, chosen for its robust networking libraries and rapid development capabilities. For cryptographic operations, we utilize the \texttt{cryptography} library from the Python Cryptographic Authority (PyCA), which provides well-tested implementations of standard algorithms. The system interfaces with the Linux TUN/TAP driver to create virtual network interfaces, and uses UDP over IPv4 as the transport protocol to avoid TCP-over-TCP performance issues. The entire system is designed to run on Linux operating systems, specifically tested on Ubuntu 20.04 and later versions.

\subsubsection{Cryptographic Specifications}

For symmetric encryption, the system employs AES-256 in Counter (CTR) mode. This configuration uses 256-bit (32-byte) encryption keys and generates unique 128-bit (16-byte) initialization vectors for each packet. CTR mode was selected because it provides stream encryption capabilities, allowing efficient processing of variable-length packets without requiring padding that would expand the payload size.

Message authentication is achieved through HMAC-SHA256, which uses a separate 256-bit key to produce 256-bit authentication tags. The HMAC calculation covers the entire packet structure, including the IV, sequence number, and ciphertext, ensuring that any tampering with any component of the packet will be detected.

Key derivation follows a simple but effective key-splitting approach. The system requires a master key of at least 512 bits (64 bytes), from which two separate 256-bit keys are derived. The first 256 bits become the encryption key, while the second 256 bits serve as the HMAC key. This separation ensures that the same key material is never reused for different cryptographic purposes, adhering to fundamental security principles.

% ============================================================================
% SECTION 3: OPERATION MANUAL AND ANALYSIS
% ============================================================================
\section{Operation Manual and Analysis}

\subsection{Prerequisites}

\subsubsection{System Requirements}

Before deploying the VPN system, several prerequisites must be met. The system requires a Unix operating system, with Ubuntu 20.04 or later and MacOS being the tested Operating Systems. Python 3.7 or higher must be installed, as the implementation relies on features introduced in recent Python versions. Root or sudo privileges are essential for creating TUN interfaces, which operate at the kernel level. Finally, network connectivity must be established between the hosts that will participate in the VPN tunnel.

\subsubsection{Software Dependencies}

\begin{verbatim}
pip install cryptography
\end{verbatim}

\subsection{Installation Steps}

\textbf{Step 1: Set up Python virtual environment}

\begin{verbatim}
python3 -m venv venv
source venv/bin/activate
pip install cryptography
\end{verbatim}

\textbf{Step 2: Verify installation}

\begin{verbatim}
python3 vpn.py --help
\end{verbatim}

\subsection{Configuration}

\textbf{Generate Shared Key} (64+ characters):

\begin{verbatim}
python3 -c "import os; print(os.urandom(64).hex())"
\end{verbatim}

This generates a 128-character hexadecimal string representing 64 bytes of random data.

\subsection{Running the VPN}

\textbf{Important Note:} The VPN supports cross-platform deployment. The implementation automatically detects the operating system (macOS Darwin vs Linux) and uses the appropriate TUN interface method:
\begin{itemize}
    \item \textbf{macOS:} Native utun interface via PF\_SYSTEM socket (no third-party drivers required)
    \item \textbf{Linux:} Standard /dev/net/tun with ioctl
\end{itemize}

\subsubsection{Production Deployment Example}

This example demonstrates the actual deployment tested between macOS (client) and Linux (server) over a Tailscale mesh network.

\textbf{On Linux Server (DeepSpace9):}

\begin{small}
\begin{verbatim}
sudo python3 vpn.py server \
  --local-ip 0.0.0.0 \
  --remote-ip 100.105.100.121 \
  --local-port 5556 \
  --remote-port 5555 \
  --key "fe49ae0e83f968c23023cdab7998e72670f4b4..." \
  --tun-local 10.0.0.1 \
  --tun-remote 10.0.0.2
\end{verbatim}
\end{small}

Expected output:
\begin{verbatim}
[+] TUN interface created: tun0
[+] VPN initialized in server mode
[+] Listening on 0.0.0.0:5556
[+] TUN interface: 10.0.0.1 <-> 10.0.0.2
[+] VPN running... Press Ctrl+C to stop
\end{verbatim}

\textbf{On macOS Client (Luccas-MacBook-Pro):}

\begin{small}
\begin{verbatim}
sudo python3 vpn.py client \
  --local-ip 0.0.0.0 \
  --remote-ip 100.113.49.125 \
  --local-port 5555 \
  --remote-port 5556 \
  --key "fe49ae0e83f968c23023cdab7998e72670f4b4..." \
  --tun-local 10.0.0.2 \
  --tun-remote 10.0.0.1
\end{verbatim}
\end{small}

Expected output:
\begin{verbatim}
[+] Created utun interface: utun8
[+] utun interface configured: utun8
[+] Local: 10.0.0.2, Remote: 10.0.0.1
[+] VPN initialized in client mode
[+] Listening on 0.0.0.0:5555
[+] VPN running... Press Ctrl+C to stop
\end{verbatim}

\textbf{Configuration Notes:}
\begin{itemize}
    \item Use \texttt{--local-ip 0.0.0.0} to bind UDP socket to all interfaces
    \item Tailscale IPs (100.x.x.x range) used for encrypted transport
    \item VPN tunnel IPs (10.0.0.x) used for application traffic
    \item Encryption key must be identical on both sides (64+ characters)
\end{itemize}

\subsubsection{Test Connectivity}

\textbf{From macOS to Linux:}
\begin{verbatim}
$ ping -c 5 10.0.0.1
PING 10.0.0.1 (10.0.0.1): 56 data bytes
64 bytes from 10.0.0.1: icmp_seq=0 ttl=64 time=51.382 ms
64 bytes from 10.0.0.1: icmp_seq=1 ttl=64 time=56.308 ms
64 bytes from 10.0.0.1: icmp_seq=2 ttl=64 time=48.191 ms
64 bytes from 10.0.0.1: icmp_seq=3 ttl=64 time=44.478 ms
64 bytes from 10.0.0.1: icmp_seq=4 ttl=64 time=49.594 ms

--- 10.0.0.1 ping statistics ---
5 packets transmitted, 5 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 44.478/49.991/56.308/3.889 ms
\end{verbatim}

\textbf{From Linux to macOS:}
\begin{verbatim}
$ ping -c 5 10.0.0.2
PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.
64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=78.4 ms
64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=63.7 ms
64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=50.3 ms
64 bytes from 10.0.0.2: icmp_seq=4 ttl=64 time=95.0 ms
64 bytes from 10.0.0.2: icmp_seq=5 ttl=64 time=51.5 ms

--- 10.0.0.2 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss
rtt min/avg/max/mdev = 50.329/67.782/94.961/16.956 ms
\end{verbatim}

\textbf{Results:} Perfect bidirectional connectivity with 0\% packet loss. Average latency of approximately 50-68ms is due to Tailscale mesh network transport, not VPN encryption overhead.

\subsection{System Analysis}

\subsubsection{Packet Flow Analysis}

\textbf{Sending Path (Application $\rightarrow$ Network):}
The sending path begins when an application generates an IP packet, such as a ping request destined for 10.0.0.2. The operating system's routing table directs this packet to the tun0 interface, where the VPN application intercepts it using \texttt{os.read(tun\_fd, MTU)}. Upon receiving the packet, the VPN increments its sequence number counter and generates a fresh random 16-byte IV. The packet payload is then encrypted using AES-256-CTR with this newly generated IV. After encryption, the system calculates an HMAC-SHA256 tag over the concatenation of the IV, sequence number, and ciphertext. These components are assembled into the final VPN packet structure: IV, followed by the sequence number, HMAC, and encrypted payload. Finally, this complete packet is transmitted via UDP using \texttt{sock.sendto(encrypted\_packet, remote\_addr)}.

\textbf{Receiving Path (Network $\rightarrow$ Application):}
The receiving path initiates when an encrypted UDP packet arrives via \texttt{sock.recvfrom()}. The VPN application parses this packet by extracting the IV from bytes 0-15, the sequence number from bytes 16-19, the HMAC from bytes 20-51, and the ciphertext from byte 52 onward. Before proceeding with decryption, the system performs critical security checks. First, it recalculates the HMAC over the received data and compares it with the extracted HMAC value; any mismatch results in immediate packet rejection. Next, it verifies that the received sequence number exceeds the last processed sequence number, rejecting the packet if this check fails to prevent replay attacks. Once these validations pass, the system decrypts the ciphertext using AES-256-CTR with the extracted IV and removes any PKCS\#7 padding. The resulting plaintext IP packet is written to the TUN interface using \texttt{os.write(tun\_fd, plaintext)}, where the operating system delivers it to the destination application.

\subsubsection{Timing Behavior}

\begin{center}
\begin{tabular}{|l|c|}
\hline
\textbf{Operation} & \textbf{Time (ms)} \\
\hline
Encryption (1500 bytes) & 0.014 \\
\hline
Decryption (1500 bytes) & 0.012 \\
\hline
Round-Trip Crypto Latency & 0.026 \\
\hline
Standard Deviation & 0.001 \\
\hline
\end{tabular}
\end{center}

\textbf{Analysis:} Cryptographic operations add negligible latency ($<$0.03ms) compared to typical network latency (1-100ms). The implementation is not a bottleneck for most network scenarios.

\subsubsection{Cross-Platform TUN Interface Implementation}

The VPN implementation supports both macOS and Linux through platform-specific TUN interface handling:

\textbf{macOS (Darwin) Implementation:}
\begin{itemize}
    \item Uses native \texttt{utun} interface via \texttt{PF\_SYSTEM} socket
    \item No third-party drivers required (e.g., Tunnelblick not needed)
    \item Creates socket with \texttt{SYSPROTO\_CONTROL} protocol
    \item Connects to kernel control "com.apple.net.utun\_control"
    \item Automatically assigns available utun device (utun0-utun15)
    \item Configuration via \texttt{ifconfig} and \texttt{route} commands
    \item Packet format: 4-byte protocol family header + IP packet
    \item Header stripped on read, added on write
\end{itemize}

\textbf{Linux Implementation:}
\begin{itemize}
    \item Uses standard \texttt{/dev/net/tun} device
    \item Creates interface via \texttt{ioctl} with \texttt{TUNSETIFF}
    \item Configuration via \texttt{ip addr} and \texttt{ip route} commands
    \item Packet format: Raw IP packets (no header)
\end{itemize}

\textbf{Platform Detection:}
The implementation automatically detects the operating system using Python's \texttt{platform.system()} and selects the appropriate TUN creation method. This ensures transparent operation without user intervention.

\textbf{Production Deployment Verification:}
\begin{center}
\begin{tabular}{|l|l|l|}
\hline
\textbf{System} & \textbf{OS} & \textbf{Interface} \\
\hline
macOS Client & macOS 26.1 (Build 25B78) & utun8 \\
\hline
Linux Server & Ubuntu 6.8.0-87-generic & tun0 \\
\hline
\end{tabular}
\end{center}

Both systems successfully established encrypted tunnel with 0\% packet loss, demonstrating robust cross-platform compatibility.

\section{Observations and Comments}

\subsection{Observations}

\subsubsection{Did the system behave as expected?}

The VPN system behaved as expected and successfully met all functional requirements across multiple dimensions. From a performance perspective, the system demonstrated exceptional throughput, achieving 870 Mbps for encryption and 1023 Mbps for decryption on MTU-sized packets, substantially exceeding our initial performance targets.

Security testing validated all critical properties of the implementation. The HMAC authentication mechanism achieved 100\% detection of tampering attempts, ensuring that no modified packets could pass through undetected. The sequence number verification completely prevented replay attacks, while the unique IV generation for each packet maintained the cryptographic strength of the CTR mode encryption. Furthermore, semantic security was preserved, confirming that identical plaintexts consistently produced different ciphertexts.

The connectivity testing demonstrated the VPN's versatility in handling various network protocols. The system successfully tunneled ICMP traffic (such as ping requests), TCP-based applications including HTTP and SSH, and UDP-based applications. Bidirectional communication functioned flawlessly in all scenarios, with packets flowing smoothly in both directions through the encrypted tunnel.

Reliability testing revealed robust behavior under challenging conditions. When presented with incorrect decryption keys, the system immediately rejected packets without attempting processing, protecting against unauthorized access. During network interruptions, the system exhibited graceful degradation rather than crashing, although due to no buffer, packets are lost. Under high packet rates and consistent connection, the implementation maintained zero packet loss, demonstrating its capacity to handle production-level or near production-level traffic loads.

\subsubsection{Timing Behavior Observations}

Timing analysis revealed highly consistent and predictable performance characteristics. The system exhibited remarkably low latency variance, with a standard deviation of only 0.001 milliseconds, indicating stable and deterministic cryptographic processing. Performance remained consistent even under heavy load conditions, with no significant degradation observed during stress testing. Additionally, processing time scaled linearly with packet size, demonstrating efficient handling of both small and large packets without algorithmic bottlenecks.

\subsection{Comments}

\subsubsection{What could we have done better?}

Several areas present opportunities for enhancement in future iterations. The current key management approach relies on pre-shared keys, which, while functional for demonstration purposes, falls short of production security standards. A more robust implementation would incorporate Diffie-Hellman key exchange to enable dynamic key establishment, implement perfect forward secrecy to protect past communications even if current keys are compromised, and support periodic key rotation to limit the impact of potential key compromise.

The packet reordering strategy currently employs strict sequence number checking, which effectively prevents replay attacks but also rejects legitimate packets that arrive out of order due to network conditions. Implementing something like a sliding window mechanism could solve this. A sliding window mechanism allows for packets to be sent in a "window." The window is moved forward, letting new packets in, when the oldest packets are acknowledged. This would provide the same security guarantees while accommodating the inherent packet reordering that occurs in real-world networks, thereby improving robustness and reducing unnecessary packet loss.

Platform portability represents another limitation of the current implementation. The TUN interface code is tightly coupled to Linux-specific APIs, restricting deployment to Linux systems. Expanding support to include Windows and macOS would significantly increase the system's usability and adoption potential, though this would require substantial refactoring to abstract platform-specific networking code.

Connection management could be significantly enhanced through the addition of a formal handshake protocol. Such a protocol would facilitate initial authentication between VPN endpoints, enable negotiation of cryptographic parameters and supported features, and provide better error reporting when connection establishment fails. This would transform the current implicit connection model into a more robust and user-friendly explicit connection framework.

While current performance metrics are strong, several optimization opportunities remain unexplored. Packet batching could reduce system call overhead by processing multiple packets in a single operation. Implementing zero-copy I/O techniques would eliminate unnecessary memory copies between user space and kernel space. Finally, leveraging multi-threading for cryptographic operations could exploit modern multi-core processors to achieve even higher throughput, particularly for scenarios involving multiple simultaneous VPN tunnels.

\subsubsection{Development Process Comments}

The development process yielded valuable insights into both successful practices and areas requiring improvement. Several aspects of the project proceeded smoothly and contributed to the final success. The modular design philosophy, separating packet handling, cryptographic operations, and network communication into distinct components, significantly simplified testing and debugging. The choice of a well-established cryptography library provided a solid foundation, eliminating the need to implement low-level cryptographic primitives and reducing the risk of implementation errors. Additionally, the incremental development approach, building features one at a time with continuous testing, enabled early detection of bugs before they could compound into more serious issues.

However, the project also encountered significant challenges that required careful resolution. The most critical issue was an IV reuse bug in the initial implementation. The IV was generated once during initialization and reused for all subsequent packets, which completely compromised the security of CTR mode encryption. This severe vulnerability was discovered through comprehensive security testing and rectified by modifying the code to generate a unique IV for each packet. Beyond this critical bug, working with TUN interfaces presented challenges related to permissions and privilege management, requiring careful handling of root access. Additionally, the current implementation does not handle sequence number wraparound, meaning the system would fail after processing $2^{32}$ packets---a limitation that would need addressing for long-running production deployments.

The debugging and testing process provided several important lessons. Most significantly, comprehensive testing proved its value by catching the IV reuse vulnerability before deployment, preventing what could have been a catastrophic security failure in a production environment. The experience reinforced the importance of dedicated unit tests for cryptographic primitives, as subtle bugs in security-critical code can have devastating consequences. Finally, the project demonstrated that security testing must be integrated early in the development cycle and conducted frequently throughout the implementation process, rather than being relegated to a final validation step.

\section{Lessons Learned}

\subsection{Difficulty and Success Assessment}

\subsubsection{How difficult was it to use the concepts?}

The project required integrating multiple computer networking concepts, each presenting varying levels of complexity. Working with TUN interfaces, UDP sockets, and packet encapsulation proved to be of moderate difficulty. While these concepts required careful attention to detail and understanding of low-level networking, they were well-documented and followed predictable patterns. The cryptographic implementation presented high difficulty, as ensuring the absence of security vulnerabilities demanded both theoretical knowledge and practical vigilance. The most challenging aspect was understanding subtle cryptographic issues, particularly the implications of IV reuse in CTR mode---a seemingly minor implementation detail that could completely undermine the security of the entire system.

\subsubsection{Were we successful?}

The project achieved success across all measured dimensions. The final implementation meets every functional requirement specified at the project's outset, demonstrating complete VPN functionality with robust security properties. The comprehensive test suite of 114 test cases passed with a 100\% success rate, validating both the correctness and reliability of the implementation. Security testing confirmed strong cryptographic properties, including proper encryption, authentication, and protection against common attack vectors. Performance benchmarks exceeded initial targets, achieving excellent throughput and minimal latency overhead. Most importantly, the critical IV reuse vulnerability discovered during development was identified and corrected, transforming a potentially catastrophic security flaw into a valuable learning experience about the importance of thorough testing.

\subsection{Computer Networks Concepts Reinforced}

This project provided hands-on experience with numerous computer networking concepts, significantly deepening our understanding of network protocols and security.

\textbf{OSI Model Layering:} The implementation reinforced understanding of how VPNs operate at Layer 3 (the Network Layer) of the OSI model. We gained practical experience with encapsulation by implementing IP-in-UDP tunneling, where IP packets are wrapped within UDP datagrams for transmission across the physical network. Working directly with raw IP packets provided insight into network layer operations that are typically abstracted away by higher-level networking libraries.

\textbf{Packet Structure and Headers:} Designing a custom packet format required deep engagement with the principles of protocol design. We implemented proper network byte order encoding to ensure cross-platform compatibility and gained practical understanding of MTU limitations and their implications for fragmentation. These experiences highlighted the careful balance between header overhead and protocol functionality.

\textbf{UDP vs TCP Trade-offs:} The decision to use UDP rather than TCP illustrated important protocol trade-offs. By choosing UDP, we avoided the well-known TCP-over-TCP performance degradation problem that occurs when TCP is tunneled within another TCP connection. This choice required understanding connectionless communication and developing strategies to handle potential packet loss at the application layer, demonstrating that reliability can be implemented at different layers of the protocol stack.

\textbf{Routing and Network Interfaces:} Configuring virtual TUN interfaces and setting up routing tables provided practical experience with network configuration. We learned how to properly address interfaces using subnet notation (such as 10.0.0.0/24) and how the operating system's routing decisions determine which interface handles particular packets.

\textbf{Network Security:} Implementing cryptographic protocols provided thorough grounding in the CIA triad---Confidentiality, Integrity, and Availability. The project exposed us to various attack vectors including man-in-the-middle attacks, replay attacks, bit-flipping attacks, and IV reuse attacks. Understanding these threats and implementing countermeasures transformed abstract security concepts into concrete implementation requirements.

\textbf{Performance Analysis:} Conducting performance analysis taught us to measure throughput in bits per second, analyze latency and round-trip time, and calculate protocol overhead percentages. These metrics provided quantitative validation of design decisions and highlighted the performance impact of security mechanisms.

\textbf{Socket Programming:} Working with the Python socket API reinforced fundamental networking programming skills. We implemented select() for I/O multiplexing to efficiently monitor multiple file descriptors simultaneously, and handled non-blocking I/O to prevent the VPN application from stalling while waiting for network events.

\subsection{Key Technical Insights}

\subsubsection{Cryptography Lessons}

The cryptographic aspects of the project yielded several critical insights. First and foremost, IV uniqueness is absolutely critical when using CTR mode encryption. Reusing an IV, even once, completely breaks the security guarantees of CTR mode by allowing attackers to recover plaintext through simple XOR operations on ciphertexts. This seemingly small implementation detail has enormous security implications.

The importance of proper authentication became clear through implementation. The HMAC must cover the entire packet structure, including the IV, to prevent tampering with any component. An attacker who can modify the IV without detection can potentially manipulate the decrypted plaintext in predictable ways, even without knowing the encryption key.

Key separation emerged as a fundamental security principle. Never should the same key material be used for both encryption and authentication. Doing so can lead to subtle but devastating cryptographic vulnerabilities. Our implementation derives separate keys from a master key, ensuring that encryption and authentication operate with independent key material.

\subsubsection{Networking Lessons}

Several networking concepts became clearer through practical implementation. The distinction between TUN and TAP interfaces is more than academic---TUN operates at Layer 3 (IP packets), while TAP operates at Layer 2 (Ethernet frames). For VPN applications, TUN is sufficient and more efficient, as we only need to tunnel IP traffic without concerning ourselves with lower-layer Ethernet details.

MTU considerations proved important for optimizing performance. The standard 1500-byte MTU represents the maximum packet size on most networks, but VPN overhead (in our case, 52-68 bytes) reduces the effective MTU available to applications. Understanding this constraint is crucial for avoiding fragmentation and maintaining performance.

The choice of UDP over TCP illustrated an important lesson about protocol layering. While UDP is inherently unreliable, it's actually perfect for VPNs because higher-layer protocols like TCP provide their own reliability mechanisms. Using TCP to tunnel TCP (TCP-over-TCP) creates serious performance problems due to interacting retransmission mechanisms.

\subsubsection{Software Engineering Lessons}

Beyond technical networking and cryptography concepts, the project reinforced fundamental software engineering principles. Comprehensive testing proved its worth by catching the IV reuse bug---a flaw that would have been catastrophic in production, potentially exposing all encrypted communications. This experience demonstrated that testing is not merely a validation step but a critical safety mechanism.

Modular design significantly eased development and debugging. By separating concerns into distinct components---VPNPacket for packet handling, VPN for overall coordination, and isolated crypto functions---we could test each component independently and reason about the system's behavior more easily. When bugs arose, the modular structure helped isolate the problem quickly.

Finally, documentation proved its value throughout the project. Clear docstrings and comments made the code significantly easier to debug when issues arose and simplified the process of extending functionality. What seemed like overhead during initial development paid dividends during debugging and testing phases.

\subsection{Real-World Applications}

This project provided hands-on experience with concepts directly applicable to production VPN systems deployed worldwide. Our implementation shares fundamental principles with WireGuard, a modern high-performance VPN that employs similar architectural concepts, though it uses different cryptographic primitives (ChaCha20 for encryption and Poly1305 for authentication). The project also illuminated the design philosophy behind OpenVPN, which uses TLS for key exchange and AES for encryption, demonstrating how established protocols can be composed to build secure systems. Furthermore, our Layer 3 implementation mirrors IPSec's approach of operating at the IP layer, providing insight into one of the most widely deployed VPN standards in enterprise and government networks.

Beyond the specific technical knowledge gained, the project developed several industry-relevant skills. We gained practical experience implementing cryptographic protocols, moving beyond theoretical understanding to confront the challenges of secure implementation. Network programming skills were honed through direct interaction with sockets, interfaces, and packet manipulation. Security testing and vulnerability assessment became concrete activities rather than abstract concepts, as we actively sought and remediated security flaws. Performance benchmarking taught us to measure and optimize system behavior quantitatively. Finally, the process of creating comprehensive technical documentation reinforced the importance of clear communication in technical projects, a skill as critical as coding ability in professional software development.

\newpage
\appendix

\section{Source Code}

The complete source code for the VPN implementation is provided below. The implementation consists of 254 lines of well-commented Python code.

\subsection{Main VPN Implementation (vpn.py)}

\textbf{Key Classes and Methods:}

\begin{small}
\begin{verbatim}
class VPNPacket:
    """
    VPN Packet Format (FIXED - unique IV per packet):
    [16 bytes: IV][4 bytes: sequence number]
    [32 bytes: HMAC][N bytes: encrypted payload]
    
    Security improvements:
    - Unique IV generated for each packet 
    - HMAC covers IV + header + encrypted payload
    - Sequence numbers prevent replay attacks
    """
    IV_SIZE = 16
    HEADER_SIZE = 4
    HMAC_SIZE = 32
    
    def pack(self, encryption_key, hmac_key):
        """Encrypt and pack packet with unique IV"""
        # Generate NEW IV for THIS packet
        iv = os.urandom(16)
        
        # Create cipher with the new IV
        cipher = Cipher(
            algorithms.AES(encryption_key),
            modes.CTR(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        
        # Encrypt payload with padding
        padding_length = 16 - (len(self.payload) % 16)
        padded_payload = (self.payload +
                          bytes([padding_length] * padding_length))
        encrypted_payload = (encryptor.update(padded_payload) +
                             encryptor.finalize())
        
        # Create header
        header = struct.pack('!I', self.seq_num)
        
        # Calculate HMAC over IV + header + encrypted
        h = hmac.HMAC(hmac_key, hashes.SHA256())
        h.update(iv + header + encrypted_payload)
        hmac_value = h.finalize()
        
        # Return: IV + header + HMAC + encrypted_payload
        return iv + header + hmac_value + encrypted_payload
\end{verbatim}
\end{small}

\subsection{Key Features}

The implementation consists of several key components working in concert. The VPNPacket class handles all packet encryption and decryption operations, with particular attention to generating unique IVs for each encrypted packet. The VPN class contains the main application logic, managing TUN interface operations and coordinating network communication. Security is ensured through AES-256-CTR encryption for confidentiality and HMAC-SHA256 authentication for integrity. Replay protection is implemented through strict sequence number verification, preventing attackers from capturing and retransmitting valid packets.

\textit{Note: Full source code (254 lines) is available in the project repository.}

\section{Test Cases}

\subsection{Test Summary}

A comprehensive test suite was developed covering 114 test cases across 7 categories:

\begin{center}
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Category} & \textbf{Total} & \textbf{Passed} & \textbf{Failed} & \textbf{Success} \\
\hline
Unit Tests & 5 & 5 & 0 & 100\% \\
\hline
Security - Basic & 18 & 18 & 0 & 100\% \\
\hline
Security - Comprehensive & 35 & 35 & 0 & 100\% \\
\hline
Performance Tests & 25 & 25 & 0 & 100\% \\
\hline
Integration Tests & 16 & 16 & 0 & 100\% \\
\hline
Stress Tests & 5 & 5 & 0 & 100\% \\
\hline
Error Handling & 10 & 10 & 0 & 100\% \\
\hline
\textbf{TOTAL} & \textbf{114} & \textbf{114} & \textbf{0} & \textbf{100\%} \\
\hline
\end{tabular}
\end{center}

\subsection{Sample Test Cases}

\subsubsection{Security Test - HMAC Integrity}

\begin{center}
\small
\begin{tabular}{|c|p{5cm}|p{5cm}|c|}
\hline
\textbf{Step} & \textbf{Action} & \textbf{Expected Behavior} & \textbf{Result} \\
\hline
1 & Create and encrypt packet & Packet includes HMAC tag & PASS \\
\hline
2 & Tamper with IV (flip 1 bit) & HMAC verification fails & PASS \\
\hline
3 & Restore IV, tamper with seq & HMAC verification fails & PASS \\
\hline
4 & Restore seq, tamper ciphertext & HMAC verification fails & PASS \\
\hline
5 & Use unmodified packet & HMAC verification succeeds & PASS \\
\hline
\end{tabular}
\end{center}

\subsubsection{Security Test - IV Uniqueness (Critical Fix)}

\begin{center}
\small
\begin{tabular}{|c|p{5cm}|p{5cm}|c|}
\hline
\textbf{Step} & \textbf{Action} & \textbf{Expected Behavior} & \textbf{Result} \\
\hline
1 & Encrypt same plaintext twice & Two packets created & PASS \\
\hline
2 & Extract IV from packet 1 & IV extracted (16 bytes) & PASS \\
\hline
3 & Extract IV from packet 2 & IV extracted (16 bytes) & PASS \\
\hline
4 & Compare IV1 and IV2 & IVs are different & PASS \\
\hline
5 & Verify ciphertext1 $\neq$ ciphertext2 & Ciphertexts differ & PASS \\
\hline
6 & Verify semantic security & Cannot derive plaintext & PASS \\
\hline
\end{tabular}
\end{center}

\textit{Note: Complete test documentation with all 114 test cases is available in TEST\_CASES.md}

\section{Performance Results}

\subsection{Encryption Throughput}

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Packet Size} & \textbf{Throughput} & \textbf{Packets/sec} & \textbf{Time/pkt} \\
\hline
64 bytes & 20.26 Mbps & 39,561.8 & 0.025 ms \\
\hline
256 bytes & 145.83 Mbps & 71,204.5 & 0.014 ms \\
\hline
512 bytes & 291.18 Mbps & 71,088.7 & 0.014 ms \\
\hline
1024 bytes & 599.35 Mbps & 73,163.3 & 0.014 ms \\
\hline
1500 bytes & \textbf{869.99 Mbps} & 72,499.3 & 0.014 ms \\
\hline
\end{tabular}
\end{center}

\subsection{Decryption Throughput}

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Packet Size} & \textbf{Throughput} & \textbf{Packets/sec} & \textbf{Time/pkt} \\
\hline
64 bytes & 44.84 Mbps & 87,580.2 & 0.011 ms \\
\hline
256 bytes & 188.69 Mbps & 92,133.9 & 0.011 ms \\
\hline
512 bytes & 375.85 Mbps & 91,761.0 & 0.011 ms \\
\hline
1024 bytes & 726.64 Mbps & 88,700.8 & 0.011 ms \\
\hline
1500 bytes & \textbf{1023.40 Mbps} & 85,283.0 & 0.012 ms \\
\hline
\end{tabular}
\end{center}

\subsection{Packet Overhead Analysis}

VPN packet format: [16 bytes IV][4 bytes seq][32 bytes HMAC][N bytes encrypted payload] = 52 bytes overhead

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Payload Size} & \textbf{VPN Packet} & \textbf{Overhead} & \textbf{Overhead \%} \\
\hline
64 bytes & 116 bytes & 52 bytes & 81.25\% \\
\hline
256 bytes & 308 bytes & 52 bytes & 20.31\% \\
\hline
512 bytes & 564 bytes & 52 bytes & 10.16\% \\
\hline
1024 bytes & 1076 bytes & 52 bytes & 5.08\% \\
\hline
1500 bytes & 1552 bytes & 52 bytes & \textbf{3.47\%} \\
\hline
\end{tabular}
\end{center}

Note: Overhead includes 16-byte IV (unique per packet), 4-byte sequence number (replay protection), and 32-byte HMAC-SHA256 (integrity protection).

\subsection{Latency Statistics}

\subsubsection{Laboratory Testing (Local Network)}

For 1500-byte packets over 1000 iterations on localhost:

\begin{itemize}
    \item \textbf{Mean:} 0.0138 ms
    \item \textbf{Median:} 0.0135 ms
    \item \textbf{Standard Deviation:} 0.0013 ms
    \item \textbf{Minimum:} 0.0133 ms
    \item \textbf{Maximum:} 0.0474 ms
\end{itemize}

\subsubsection{Production Testing (Internet via Tailscale)}

Real-world deployment between macOS client and Linux server over Tailscale mesh network:

\textbf{macOS $\rightarrow$ Linux (20 packets):}
\begin{itemize}
    \item \textbf{Mean RTT:} 57.427 ms
    \item \textbf{Minimum RTT:} 42.864 ms
    \item \textbf{Maximum RTT:} 101.086 ms
    \item \textbf{Standard Deviation:} 15.234 ms
    \item \textbf{Packet Loss:} 0.0\%
\end{itemize}

\textbf{Linux $\rightarrow$ macOS (5 packets):}
\begin{itemize}
    \item \textbf{Mean RTT:} 67.782 ms
    \item \textbf{Minimum RTT:} 50.329 ms
    \item \textbf{Maximum RTT:} 94.961 ms
    \item \textbf{Standard Deviation:} 16.956 ms
    \item \textbf{Packet Loss:} 0.0\%
\end{itemize}

\textbf{Analysis:} The production latency (50-68ms average) is dominated by network transport (Tailscale over internet), not VPN encryption overhead. The laboratory testing shows encryption/decryption adds only ~0.014ms per packet, demonstrating efficient cryptographic implementation.

\subsection{Network Impact Estimation}

\begin{itemize}
    \item \textbf{Baseline:} 100 Mbps
    \item \textbf{VPN Overhead:} 3.7\% (for MTU-sized packets)
    \item \textbf{Effective Bandwidth:} 96.40 Mbps
    \item \textbf{Bandwidth Reduction:} 3.6 Mbps (3.6\%)
\end{itemize}

\textbf{Conclusion:} The VPN introduces minimal performance overhead while providing strong security guarantees.

\section{Architecture Diagrams}

\subsection{System Architecture}

\begin{small}
\begin{verbatim}
    Host A                              Host B
+--------------+                    +--------------+
| Application  |                    | Application  |
+------+-------+                    +------+-------+
       | IP Packet                         | IP Packet
+------v-------+                    +------v-------+
| TUN (tun0)   |                    | TUN (tun0)   |
|  10.0.0.1    |                    |  10.0.0.2    |
+------+-------+                    +------+-------+
       |                                   |
+------v----------------+      +-----------v------+
| VPN APPLICATION       |      | VPN APPLICATION  |
|                       |      |                  |
| 1. Read from TUN      |      | 1. Recv UDP      |
| 2. Gen IV, Inc Seq    |      | 2. Verify HMAC   |
| 3. Encrypt AES-256    |      | 3. Check Seq     |
| 4. Calc HMAC-SHA256   |      | 4. Decrypt       |
| 5. Send UDP           |      | 5. Write to TUN  |
+-------+---------------+      +-----------+------+
        |                                  |
  +-----v------+                    +------v-----+
  | UDP Socket |                    | UDP Socket |
  |192.168.1.10|                    |192.168.1.20|
  +-----+------+                    +------+-----+
        |                                  |
        +----------> Internet <------------+
                 (Encrypted UDP)
\end{verbatim}
\end{small}

\subsection{VPN Packet Format}

\begin{small}
\begin{verbatim}
 0               1               2               3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+---------------------------------------------------------------+
|                      IV (128 bits)                            |
|                                                               |
+---------------------------------------------------------------+
|                    Sequence Number                            |
+---------------------------------------------------------------+
|                   HMAC-SHA256 (256 bits)                      |
|                                                               |
+---------------------------------------------------------------+
|                  Encrypted Payload (Variable)                 |
|                      (AES-256-CTR)                            |
+---------------------------------------------------------------+

Total Header: 52 bytes (16 + 4 + 32)
Overhead with padding: 52-68 bytes
\end{verbatim}
\end{small}

\subsection{Security Architecture}

\begin{small}
\begin{verbatim}
+-------------------------------------------------------+
| CONFIDENTIALITY                                       |
|  * AES-256 encryption                                 |
|  * Unique IV per packet                               |
|  * Semantic security                                  |
+-------------------------------------------------------+

+-------------------------------------------------------+
| INTEGRITY                                             |
|  * HMAC-SHA256 authentication                         |
|  * Covers IV + Seq + Ciphertext                       |
|  * Detects any tampering                              |
+-------------------------------------------------------+

+-------------------------------------------------------+
| AVAILABILITY                                          |
|  * Replay protection (sequence numbers)               |
|  * Handles network interruptions                      |
|  * High throughput (>800 Mbps)                        |
+-------------------------------------------------------+

+-------------------------------------------------------+
| AUTHENTICATION                                        |
|  * Pre-shared key                                     |
|  * HMAC prevents forgery                              |
|  * Wrong key -> immediate rejection                   |
+-------------------------------------------------------+
\end{verbatim}
\end{small}

\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}

This project successfully implemented a fully functional Virtual Private Network with strong security properties, demonstrating complete VPN functionality through secure tunneling between hosts with robust bidirectional communication. The implementation employs strong cryptography, combining AES-256-CTR encryption with HMAC-SHA256 authentication to ensure both confidentiality and integrity of all transmitted data. A critical achievement was identifying and resolving an IV reuse vulnerability during development, transforming a large security flaw into a learning opportunity and ensuring semantic security (ciphertext reveals no information about the plaintext) in the final implementation.

The quality of the implementation is validated through comprehensive testing, with all 114 test cases passing at a 100\% success rate. Performance metrics demonstrate excellent efficiency, achieving over 870 Mbps throughput while maintaining latency overhead below 0.03 milliseconds. The protocol imposes minimal overhead of just 3.7\% for MTU-sized packets, making it practical for real-world deployment without significantly degrading network performance.

Beyond the technical achievements, the project provided invaluable hands-on experience with fundamental computer networking concepts. We gained practical understanding of packet encapsulation, cryptographic protocol implementation, security testing methodologies, and performance analysis techniques. The comprehensive documentation and rigorous testing process demonstrate not only mastery of theoretical concepts but also the ability to navigate the practical challenges inherent in implementing secure network systems. This experience bridges the gap between classroom learning and real-world software development, preparing us for the challenges of professional network engineering and security work.

\begin{thebibliography}{9}

\bibitem{aes}
National Institute of Standards and Technology (NIST).
\textit{Advanced Encryption Standard (AES)}.
FIPS PUB 197, 2001.

\bibitem{hmac}
Krawczyk, H., Bellare, M., and Canetti, R.
\textit{HMAC: Keyed-Hashing for Message Authentication}.
RFC 2104, 1997.

\bibitem{vpn}
Kent, S. and Atkinson, R.
\textit{Security Architecture for the Internet Protocol}.
RFC 2401, 1998.

\bibitem{cryptography}
Python Cryptographic Authority.
\textit{Cryptography Library Documentation}.
\url{https://cryptography.io/}, 2024.

\bibitem{tun}
Linux Kernel Documentation.
\textit{Universal TUN/TAP device driver}.
\url{https://www.kernel.org/doc/Documentation/networking/tuntap.txt}

\end{thebibliography}

\end{document}

